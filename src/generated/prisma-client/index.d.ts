// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  expertise: (where?: ExpertiseWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  research: (where?: ResearchWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  expertise: (where: ExpertiseWhereUniqueInput) => ExpertiseNullablePromise;
  expertises: (args?: {
    where?: ExpertiseWhereInput;
    orderBy?: ExpertiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expertise>;
  expertisesConnection: (args?: {
    where?: ExpertiseWhereInput;
    orderBy?: ExpertiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpertiseConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  research: (where: ResearchWhereUniqueInput) => ResearchNullablePromise;
  researches: (args?: {
    where?: ResearchWhereInput;
    orderBy?: ResearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Research>;
  researchesConnection: (args?: {
    where?: ResearchWhereInput;
    orderBy?: ResearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ResearchConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createExpertise: (data: ExpertiseCreateInput) => ExpertisePromise;
  updateExpertise: (args: {
    data: ExpertiseUpdateInput;
    where: ExpertiseWhereUniqueInput;
  }) => ExpertisePromise;
  updateManyExpertises: (args: {
    data: ExpertiseUpdateManyMutationInput;
    where?: ExpertiseWhereInput;
  }) => BatchPayloadPromise;
  upsertExpertise: (args: {
    where: ExpertiseWhereUniqueInput;
    create: ExpertiseCreateInput;
    update: ExpertiseUpdateInput;
  }) => ExpertisePromise;
  deleteExpertise: (where: ExpertiseWhereUniqueInput) => ExpertisePromise;
  deleteManyExpertises: (where?: ExpertiseWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createResearch: (data: ResearchCreateInput) => ResearchPromise;
  updateResearch: (args: {
    data: ResearchUpdateInput;
    where: ResearchWhereUniqueInput;
  }) => ResearchPromise;
  updateManyResearches: (args: {
    data: ResearchUpdateManyMutationInput;
    where?: ResearchWhereInput;
  }) => BatchPayloadPromise;
  upsertResearch: (args: {
    where: ResearchWhereUniqueInput;
    create: ResearchCreateInput;
    update: ResearchUpdateInput;
  }) => ResearchPromise;
  deleteResearch: (where: ResearchWhereUniqueInput) => ResearchPromise;
  deleteManyResearches: (where?: ResearchWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  expertise: (
    where?: ExpertiseSubscriptionWhereInput
  ) => ExpertiseSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  research: (
    where?: ResearchSubscriptionWhereInput
  ) => ResearchSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Gender = "MALE" | "FEMALE";

export type AccessRole = "ADMIN" | "STUDENT" | "PROFESSOR";

export type EducationStatus = "NULL" | "STUDYING" | "NOTSTUDYING" | "GRADUATE";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExpertiseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResearchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "img_url_ASC"
  | "img_url_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "prefix_ASC"
  | "prefix_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "role_ASC"
  | "role_DESC"
  | "student_status_ASC"
  | "student_status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpdateWithoutPostsDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  img_url?: Maybe<String>;
  gender?: Maybe<Gender>;
  prefix?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  address?: Maybe<AddressUpdateOneInput>;
  role?: Maybe<AccessRole>;
  student_status?: Maybe<EducationStatus>;
  professor_expertise?: Maybe<ExpertiseUpdateManyInput>;
  professor_research?: Maybe<ResearchUpdateManyInput>;
}

export type ExpertiseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  username: String;
  email: String;
  password: String;
  img_url?: Maybe<String>;
  gender?: Maybe<Gender>;
  prefix?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  address?: Maybe<AddressCreateOneInput>;
  role?: Maybe<AccessRole>;
  student_status?: Maybe<EducationStatus>;
  professor_expertise?: Maybe<ExpertiseCreateManyInput>;
  professor_research?: Maybe<ResearchCreateManyInput>;
}

export interface FileUpdateManyMutationInput {
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
}

export type SocialWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  addr?: Maybe<String>;
  district?: Maybe<String>;
  amphoe?: Maybe<String>;
  province?: Maybe<String>;
  zipcode?: Maybe<Int>;
  social?: Maybe<SocialCreateOneInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface SocialCreateOneInput {
  create?: Maybe<SocialCreateInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface SocialCreateInput {
  id?: Maybe<ID_Input>;
  phone?: Maybe<Int>;
  line_id?: Maybe<String>;
  facebook?: Maybe<String>;
  etc?: Maybe<String>;
}

export interface ExpertiseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpertiseWhereInput>;
  AND?: Maybe<
    ExpertiseSubscriptionWhereInput[] | ExpertiseSubscriptionWhereInput
  >;
}

export interface ExpertiseCreateManyInput {
  create?: Maybe<ExpertiseCreateInput[] | ExpertiseCreateInput>;
  connect?: Maybe<ExpertiseWhereUniqueInput[] | ExpertiseWhereUniqueInput>;
}

export interface PostUpdateManyDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface ResearchCreateManyInput {
  create?: Maybe<ResearchCreateInput[] | ResearchCreateInput>;
  connect?: Maybe<ResearchWhereUniqueInput[] | ResearchWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  img_url?: Maybe<String>;
  img_url_not?: Maybe<String>;
  img_url_in?: Maybe<String[] | String>;
  img_url_not_in?: Maybe<String[] | String>;
  img_url_lt?: Maybe<String>;
  img_url_lte?: Maybe<String>;
  img_url_gt?: Maybe<String>;
  img_url_gte?: Maybe<String>;
  img_url_contains?: Maybe<String>;
  img_url_not_contains?: Maybe<String>;
  img_url_starts_with?: Maybe<String>;
  img_url_not_starts_with?: Maybe<String>;
  img_url_ends_with?: Maybe<String>;
  img_url_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  prefix?: Maybe<String>;
  prefix_not?: Maybe<String>;
  prefix_in?: Maybe<String[] | String>;
  prefix_not_in?: Maybe<String[] | String>;
  prefix_lt?: Maybe<String>;
  prefix_lte?: Maybe<String>;
  prefix_gt?: Maybe<String>;
  prefix_gte?: Maybe<String>;
  prefix_contains?: Maybe<String>;
  prefix_not_contains?: Maybe<String>;
  prefix_starts_with?: Maybe<String>;
  prefix_not_starts_with?: Maybe<String>;
  prefix_ends_with?: Maybe<String>;
  prefix_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  address?: Maybe<AddressWhereInput>;
  role?: Maybe<AccessRole>;
  role_not?: Maybe<AccessRole>;
  role_in?: Maybe<AccessRole[] | AccessRole>;
  role_not_in?: Maybe<AccessRole[] | AccessRole>;
  posts_some?: Maybe<PostWhereInput>;
  student_status?: Maybe<EducationStatus>;
  student_status_not?: Maybe<EducationStatus>;
  student_status_in?: Maybe<EducationStatus[] | EducationStatus>;
  student_status_not_in?: Maybe<EducationStatus[] | EducationStatus>;
  professor_expertise_some?: Maybe<ExpertiseWhereInput>;
  professor_research_some?: Maybe<ResearchWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ResearchCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  files?: Maybe<FileCreateManyInput>;
}

export interface SocialWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phone?: Maybe<Int>;
  phone_not?: Maybe<Int>;
  phone_in?: Maybe<Int[] | Int>;
  phone_not_in?: Maybe<Int[] | Int>;
  phone_lt?: Maybe<Int>;
  phone_lte?: Maybe<Int>;
  phone_gt?: Maybe<Int>;
  phone_gte?: Maybe<Int>;
  line_id?: Maybe<String>;
  line_id_not?: Maybe<String>;
  line_id_in?: Maybe<String[] | String>;
  line_id_not_in?: Maybe<String[] | String>;
  line_id_lt?: Maybe<String>;
  line_id_lte?: Maybe<String>;
  line_id_gt?: Maybe<String>;
  line_id_gte?: Maybe<String>;
  line_id_contains?: Maybe<String>;
  line_id_not_contains?: Maybe<String>;
  line_id_starts_with?: Maybe<String>;
  line_id_not_starts_with?: Maybe<String>;
  line_id_ends_with?: Maybe<String>;
  line_id_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  etc?: Maybe<String>;
  etc_not?: Maybe<String>;
  etc_in?: Maybe<String[] | String>;
  etc_not_in?: Maybe<String[] | String>;
  etc_lt?: Maybe<String>;
  etc_lte?: Maybe<String>;
  etc_gt?: Maybe<String>;
  etc_gte?: Maybe<String>;
  etc_contains?: Maybe<String>;
  etc_not_contains?: Maybe<String>;
  etc_starts_with?: Maybe<String>;
  etc_not_starts_with?: Maybe<String>;
  etc_ends_with?: Maybe<String>;
  etc_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialWhereInput[] | SocialWhereInput>;
}

export interface FileCreateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface ResearchWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  files_some?: Maybe<FileWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ResearchWhereInput[] | ResearchWhereInput>;
}

export interface FileUpdateInput {
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
  owner?: Maybe<PostUpdateOneRequiredWithoutFilesInput>;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface PostUpdateOneRequiredWithoutFilesInput {
  create?: Maybe<PostCreateWithoutFilesInput>;
  update?: Maybe<PostUpdateWithoutFilesDataInput>;
  upsert?: Maybe<PostUpsertWithoutFilesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface PostUpdateWithoutFilesDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  img_url?: Maybe<String>;
  gender?: Maybe<Gender>;
  prefix?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  address?: Maybe<AddressUpdateOneInput>;
  role?: Maybe<AccessRole>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  student_status?: Maybe<EducationStatus>;
  professor_expertise?: Maybe<ExpertiseUpdateManyInput>;
  professor_research?: Maybe<ResearchUpdateManyInput>;
}

export interface FileCreateManyWithoutOwnerInput {
  create?: Maybe<FileCreateWithoutOwnerInput[] | FileCreateWithoutOwnerInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  files?: Maybe<FileCreateManyWithoutOwnerInput>;
}

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  email: String;
  password: String;
  img_url?: Maybe<String>;
  gender?: Maybe<Gender>;
  prefix?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  address?: Maybe<AddressCreateOneInput>;
  role?: Maybe<AccessRole>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  student_status?: Maybe<EducationStatus>;
  professor_expertise?: Maybe<ExpertiseCreateManyInput>;
  professor_research?: Maybe<ResearchCreateManyInput>;
}

export interface AddressUpdateDataInput {
  addr?: Maybe<String>;
  district?: Maybe<String>;
  amphoe?: Maybe<String>;
  province?: Maybe<String>;
  zipcode?: Maybe<Int>;
  social?: Maybe<SocialUpdateOneInput>;
}

export interface ResearchUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface SocialUpdateOneInput {
  create?: Maybe<SocialCreateInput>;
  update?: Maybe<SocialUpdateDataInput>;
  upsert?: Maybe<SocialUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SocialWhereUniqueInput>;
}

export interface PostUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface SocialUpdateDataInput {
  phone?: Maybe<Int>;
  line_id?: Maybe<String>;
  facebook?: Maybe<String>;
  etc?: Maybe<String>;
}

export interface FileUpsertWithWhereUniqueWithoutOwnerInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutOwnerDataInput;
  create: FileCreateWithoutOwnerInput;
}

export interface SocialUpsertNestedInput {
  update: SocialUpdateDataInput;
  create: SocialCreateInput;
}

export interface FileUpdateWithWhereUniqueWithoutOwnerInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutOwnerDataInput;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  files?: Maybe<FileCreateManyWithoutOwnerInput>;
}

export interface ExpertiseUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface PostUpdateInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  files?: Maybe<FileUpdateManyWithoutOwnerInput>;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
  owner: PostCreateOneWithoutFilesInput;
}

export interface ExpertiseUpdateManyInput {
  create?: Maybe<ExpertiseCreateInput[] | ExpertiseCreateInput>;
  update?: Maybe<
    | ExpertiseUpdateWithWhereUniqueNestedInput[]
    | ExpertiseUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ExpertiseUpsertWithWhereUniqueNestedInput[]
    | ExpertiseUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ExpertiseWhereUniqueInput[] | ExpertiseWhereUniqueInput>;
  connect?: Maybe<ExpertiseWhereUniqueInput[] | ExpertiseWhereUniqueInput>;
  set?: Maybe<ExpertiseWhereUniqueInput[] | ExpertiseWhereUniqueInput>;
  disconnect?: Maybe<ExpertiseWhereUniqueInput[] | ExpertiseWhereUniqueInput>;
  deleteMany?: Maybe<ExpertiseScalarWhereInput[] | ExpertiseScalarWhereInput>;
  updateMany?: Maybe<
    | ExpertiseUpdateManyWithWhereNestedInput[]
    | ExpertiseUpdateManyWithWhereNestedInput
  >;
}

export interface PostCreateWithoutFilesInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
}

export interface ExpertiseUpdateWithWhereUniqueNestedInput {
  where: ExpertiseWhereUniqueInput;
  data: ExpertiseUpdateDataInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExpertiseUpdateDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface ExpertiseUpsertWithWhereUniqueNestedInput {
  where: ExpertiseWhereUniqueInput;
  update: ExpertiseUpdateDataInput;
  create: ExpertiseCreateInput;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  files_some?: Maybe<FileWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface ExpertiseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpertiseScalarWhereInput[] | ExpertiseScalarWhereInput>;
  OR?: Maybe<ExpertiseScalarWhereInput[] | ExpertiseScalarWhereInput>;
  NOT?: Maybe<ExpertiseScalarWhereInput[] | ExpertiseScalarWhereInput>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface ExpertiseUpdateManyWithWhereNestedInput {
  where: ExpertiseScalarWhereInput;
  data: ExpertiseUpdateManyDataInput;
}

export interface ExpertiseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpertiseWhereInput[] | ExpertiseWhereInput>;
}

export interface ExpertiseUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface ResearchUpdateManyInput {
  create?: Maybe<ResearchCreateInput[] | ResearchCreateInput>;
  update?: Maybe<
    | ResearchUpdateWithWhereUniqueNestedInput[]
    | ResearchUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ResearchUpsertWithWhereUniqueNestedInput[]
    | ResearchUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ResearchWhereUniqueInput[] | ResearchWhereUniqueInput>;
  connect?: Maybe<ResearchWhereUniqueInput[] | ResearchWhereUniqueInput>;
  set?: Maybe<ResearchWhereUniqueInput[] | ResearchWhereUniqueInput>;
  disconnect?: Maybe<ResearchWhereUniqueInput[] | ResearchWhereUniqueInput>;
  deleteMany?: Maybe<ResearchScalarWhereInput[] | ResearchScalarWhereInput>;
  updateMany?: Maybe<
    | ResearchUpdateManyWithWhereNestedInput[]
    | ResearchUpdateManyWithWhereNestedInput
  >;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface ResearchUpdateWithWhereUniqueNestedInput {
  where: ResearchWhereUniqueInput;
  data: ResearchUpdateDataInput;
}

export interface ResearchUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  files?: Maybe<FileUpdateManyInput>;
}

export interface ResearchUpdateDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  files?: Maybe<FileUpdateManyInput>;
}

export interface FileUpdateWithoutOwnerDataInput {
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
}

export interface FileUpdateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface ExpertiseCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface FileCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
}

export interface FileUpdateDataInput {
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
  owner?: Maybe<PostUpdateOneRequiredWithoutFilesInput>;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  img_url?: Maybe<String>;
  gender?: Maybe<Gender>;
  prefix?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  role?: Maybe<AccessRole>;
  student_status?: Maybe<EducationStatus>;
}

export interface FileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  size?: Maybe<String>;
  size_not?: Maybe<String>;
  size_in?: Maybe<String[] | String>;
  size_not_in?: Maybe<String[] | String>;
  size_lt?: Maybe<String>;
  size_lte?: Maybe<String>;
  size_gt?: Maybe<String>;
  size_gte?: Maybe<String>;
  size_contains?: Maybe<String>;
  size_not_contains?: Maybe<String>;
  size_starts_with?: Maybe<String>;
  size_not_starts_with?: Maybe<String>;
  size_ends_with?: Maybe<String>;
  size_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  OR?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  NOT?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
}

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  size?: Maybe<String>;
  size_not?: Maybe<String>;
  size_in?: Maybe<String[] | String>;
  size_not_in?: Maybe<String[] | String>;
  size_lt?: Maybe<String>;
  size_lte?: Maybe<String>;
  size_gt?: Maybe<String>;
  size_gte?: Maybe<String>;
  size_contains?: Maybe<String>;
  size_not_contains?: Maybe<String>;
  size_starts_with?: Maybe<String>;
  size_not_starts_with?: Maybe<String>;
  size_ends_with?: Maybe<String>;
  size_not_ends_with?: Maybe<String>;
  owner?: Maybe<PostWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}>;

export interface FileUpdateManyDataInput {
  name?: Maybe<String>;
  hash?: Maybe<String>;
  size?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface ResearchUpsertWithWhereUniqueNestedInput {
  where: ResearchWhereUniqueInput;
  update: ResearchUpdateDataInput;
  create: ResearchCreateInput;
}

export interface ExpertiseUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface ResearchScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ResearchScalarWhereInput[] | ResearchScalarWhereInput>;
  OR?: Maybe<ResearchScalarWhereInput[] | ResearchScalarWhereInput>;
  NOT?: Maybe<ResearchScalarWhereInput[] | ResearchScalarWhereInput>;
}

export interface ResearchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ResearchWhereInput>;
  AND?: Maybe<
    ResearchSubscriptionWhereInput[] | ResearchSubscriptionWhereInput
  >;
}

export interface PostUpsertWithoutFilesInput {
  update: PostUpdateWithoutFilesDataInput;
  create: PostCreateWithoutFilesInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface ResearchUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface ResearchUpdateManyWithWhereNestedInput {
  where: ResearchScalarWhereInput;
  data: ResearchUpdateManyDataInput;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  addr?: Maybe<String>;
  addr_not?: Maybe<String>;
  addr_in?: Maybe<String[] | String>;
  addr_not_in?: Maybe<String[] | String>;
  addr_lt?: Maybe<String>;
  addr_lte?: Maybe<String>;
  addr_gt?: Maybe<String>;
  addr_gte?: Maybe<String>;
  addr_contains?: Maybe<String>;
  addr_not_contains?: Maybe<String>;
  addr_starts_with?: Maybe<String>;
  addr_not_starts_with?: Maybe<String>;
  addr_ends_with?: Maybe<String>;
  addr_not_ends_with?: Maybe<String>;
  district?: Maybe<String>;
  district_not?: Maybe<String>;
  district_in?: Maybe<String[] | String>;
  district_not_in?: Maybe<String[] | String>;
  district_lt?: Maybe<String>;
  district_lte?: Maybe<String>;
  district_gt?: Maybe<String>;
  district_gte?: Maybe<String>;
  district_contains?: Maybe<String>;
  district_not_contains?: Maybe<String>;
  district_starts_with?: Maybe<String>;
  district_not_starts_with?: Maybe<String>;
  district_ends_with?: Maybe<String>;
  district_not_ends_with?: Maybe<String>;
  amphoe?: Maybe<String>;
  amphoe_not?: Maybe<String>;
  amphoe_in?: Maybe<String[] | String>;
  amphoe_not_in?: Maybe<String[] | String>;
  amphoe_lt?: Maybe<String>;
  amphoe_lte?: Maybe<String>;
  amphoe_gt?: Maybe<String>;
  amphoe_gte?: Maybe<String>;
  amphoe_contains?: Maybe<String>;
  amphoe_not_contains?: Maybe<String>;
  amphoe_starts_with?: Maybe<String>;
  amphoe_not_starts_with?: Maybe<String>;
  amphoe_ends_with?: Maybe<String>;
  amphoe_not_ends_with?: Maybe<String>;
  province?: Maybe<String>;
  province_not?: Maybe<String>;
  province_in?: Maybe<String[] | String>;
  province_not_in?: Maybe<String[] | String>;
  province_lt?: Maybe<String>;
  province_lte?: Maybe<String>;
  province_gt?: Maybe<String>;
  province_gte?: Maybe<String>;
  province_contains?: Maybe<String>;
  province_not_contains?: Maybe<String>;
  province_starts_with?: Maybe<String>;
  province_not_starts_with?: Maybe<String>;
  province_ends_with?: Maybe<String>;
  province_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<Int>;
  zipcode_not?: Maybe<Int>;
  zipcode_in?: Maybe<Int[] | Int>;
  zipcode_not_in?: Maybe<Int[] | Int>;
  zipcode_lt?: Maybe<Int>;
  zipcode_lte?: Maybe<Int>;
  zipcode_gt?: Maybe<Int>;
  zipcode_gte?: Maybe<Int>;
  social?: Maybe<SocialWhereInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface PostCreateOneWithoutFilesInput {
  create?: Maybe<PostCreateWithoutFilesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface FileUpdateManyWithoutOwnerInput {
  create?: Maybe<FileCreateWithoutOwnerInput[] | FileCreateWithoutOwnerInput>;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueWithoutOwnerInput[]
    | FileUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueWithoutOwnerInput[]
    | FileUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export type ResearchWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PostUpdateWithoutAuthorDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  files?: Maybe<FileUpdateManyWithoutOwnerInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email: String;
  password: String;
  img_url?: String;
  gender?: Gender;
  prefix?: String;
  firstname?: String;
  lastname?: String;
  birthday?: DateTimeOutput;
  role: AccessRole;
  student_status?: EducationStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  img_url: () => Promise<String>;
  gender: () => Promise<Gender>;
  prefix: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  role: () => Promise<AccessRole>;
  student_status: () => Promise<EducationStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  img_url: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  prefix: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<AccessRole>>;
  student_status: () => Promise<AsyncIterator<EducationStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpertiseEdge {
  node: Expertise;
  cursor: String;
}

export interface ExpertiseEdgePromise
  extends Promise<ExpertiseEdge>,
    Fragmentable {
  node: <T = ExpertisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpertiseEdgeSubscription
  extends Promise<AsyncIterator<ExpertiseEdge>>,
    Fragmentable {
  node: <T = ExpertiseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpertise {
  count: Int;
}

export interface AggregateExpertisePromise
  extends Promise<AggregateExpertise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpertiseSubscription
  extends Promise<AsyncIterator<AggregateExpertise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Research {
  id: ID_Output;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ResearchPromise extends Promise<Research>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ResearchSubscription
  extends Promise<AsyncIterator<Research>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ResearchNullablePromise
  extends Promise<Research | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Post {
  id: ID_Output;
  published: Boolean;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ResearchPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ResearchPreviousValuesPromise
  extends Promise<ResearchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ResearchPreviousValuesSubscription
  extends Promise<AsyncIterator<ResearchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpertiseConnection {
  pageInfo: PageInfo;
  edges: ExpertiseEdge[];
}

export interface ExpertiseConnectionPromise
  extends Promise<ExpertiseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpertiseEdge>>() => T;
  aggregate: <T = AggregateExpertisePromise>() => T;
}

export interface ExpertiseConnectionSubscription
  extends Promise<AsyncIterator<ExpertiseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpertiseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpertiseSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Social {
  id: ID_Output;
  phone?: Int;
  line_id?: String;
  facebook?: String;
  etc?: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<Int>;
  line_id: () => Promise<String>;
  facebook: () => Promise<String>;
  etc: () => Promise<String>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<Int>>;
  line_id: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  etc: () => Promise<AsyncIterator<String>>;
}

export interface SocialNullablePromise
  extends Promise<Social | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<Int>;
  line_id: () => Promise<String>;
  facebook: () => Promise<String>;
  etc: () => Promise<String>;
}

export interface ResearchEdge {
  node: Research;
  cursor: String;
}

export interface ResearchEdgePromise
  extends Promise<ResearchEdge>,
    Fragmentable {
  node: <T = ResearchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResearchEdgeSubscription
  extends Promise<AsyncIterator<ResearchEdge>>,
    Fragmentable {
  node: <T = ResearchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Address {
  id: ID_Output;
  addr?: String;
  district?: String;
  amphoe?: String;
  province?: String;
  zipcode?: Int;
  social?: Social | null;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  addr: () => Promise<String>;
  district: () => Promise<String>;
  amphoe: () => Promise<String>;
  province: () => Promise<String>;
  zipcode: () => Promise<Int>;
  social: <T = SocialPromise>() => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  addr: () => Promise<AsyncIterator<String>>;
  district: () => Promise<AsyncIterator<String>>;
  amphoe: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<Int>>;
  social: <T = SocialSubscription>() => T;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  addr: () => Promise<String>;
  district: () => Promise<String>;
  amphoe: () => Promise<String>;
  province: () => Promise<String>;
  zipcode: () => Promise<Int>;
  social: <T = SocialPromise>() => T;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Expertise {
  id: ID_Output;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExpertisePromise extends Promise<Expertise>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExpertiseSubscription
  extends Promise<AsyncIterator<Expertise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpertiseNullablePromise
  extends Promise<Expertise | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface ExpertiseSubscriptionPayload {
  mutation: MutationType;
  node: Expertise;
  updatedFields: String[];
  previousValues: ExpertisePreviousValues;
}

export interface ExpertiseSubscriptionPayloadPromise
  extends Promise<ExpertiseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpertisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpertisePreviousValuesPromise>() => T;
}

export interface ExpertiseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpertiseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpertiseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpertisePreviousValuesSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExpertisePreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExpertisePreviousValuesPromise
  extends Promise<ExpertisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExpertisePreviousValuesSubscription
  extends Promise<AsyncIterator<ExpertisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface File {
  id: ID_Output;
  name?: String;
  hash?: String;
  size?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hash: () => Promise<String>;
  size: () => Promise<String>;
  owner: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<String>>;
  owner: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hash: () => Promise<String>;
  size: () => Promise<String>;
  owner: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ResearchSubscriptionPayload {
  mutation: MutationType;
  node: Research;
  updatedFields: String[];
  previousValues: ResearchPreviousValues;
}

export interface ResearchSubscriptionPayloadPromise
  extends Promise<ResearchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResearchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResearchPreviousValuesPromise>() => T;
}

export interface ResearchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResearchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResearchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResearchPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface ResearchConnection {
  pageInfo: PageInfo;
  edges: ResearchEdge[];
}

export interface ResearchConnectionPromise
  extends Promise<ResearchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResearchEdge>>() => T;
  aggregate: <T = AggregateResearchPromise>() => T;
}

export interface ResearchConnectionSubscription
  extends Promise<AsyncIterator<ResearchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResearchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResearchSubscription>() => T;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPreviousValues {
  id: ID_Output;
  published: Boolean;
  title?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  username: String;
  email: String;
  password: String;
  img_url?: String;
  gender?: Gender;
  prefix?: String;
  firstname?: String;
  lastname?: String;
  birthday?: DateTimeOutput;
  address?: Address | null;
  role: AccessRole;
  student_status?: EducationStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  img_url: () => Promise<String>;
  gender: () => Promise<Gender>;
  prefix: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  address: <T = AddressPromise>() => T;
  role: () => Promise<AccessRole>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  student_status: () => Promise<EducationStatus>;
  professor_expertise: <T = FragmentableArray<Expertise>>(args?: {
    where?: ExpertiseWhereInput;
    orderBy?: ExpertiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  professor_research: <T = FragmentableArray<Research>>(args?: {
    where?: ResearchWhereInput;
    orderBy?: ResearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  img_url: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  prefix: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  address: <T = AddressSubscription>() => T;
  role: () => Promise<AsyncIterator<AccessRole>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  student_status: () => Promise<AsyncIterator<EducationStatus>>;
  professor_expertise: <
    T = Promise<AsyncIterator<ExpertiseSubscription>>
  >(args?: {
    where?: ExpertiseWhereInput;
    orderBy?: ExpertiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  professor_research: <
    T = Promise<AsyncIterator<ResearchSubscription>>
  >(args?: {
    where?: ResearchWhereInput;
    orderBy?: ResearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  img_url: () => Promise<String>;
  gender: () => Promise<Gender>;
  prefix: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  address: <T = AddressPromise>() => T;
  role: () => Promise<AccessRole>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  student_status: () => Promise<EducationStatus>;
  professor_expertise: <T = FragmentableArray<Expertise>>(args?: {
    where?: ExpertiseWhereInput;
    orderBy?: ExpertiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  professor_research: <T = FragmentableArray<Research>>(args?: {
    where?: ResearchWhereInput;
    orderBy?: ResearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValues {
  id: ID_Output;
  name?: String;
  hash?: String;
  size?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hash: () => Promise<String>;
  size: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResearch {
  count: Int;
}

export interface AggregateResearchPromise
  extends Promise<AggregateResearch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResearchSubscription
  extends Promise<AsyncIterator<AggregateResearch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Expertise",
    embedded: false
  },
  {
    name: "Research",
    embedded: false
  },
  {
    name: "Social",
    embedded: true
  },
  {
    name: "Address",
    embedded: true
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "AccessRole",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "EducationStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
